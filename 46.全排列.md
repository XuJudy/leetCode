## 全排列

> ##### 题目链结
>
> [46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/description/?envType=problem-list-v2&envId=array)
>
> [47. 全排列 II - 力扣（LeetCode）](https://leetcode.cn/problems/permutations-ii/description/?envType=problem-list-v2&envId=array)



#### 46.全排列

##### 解题思想

将问题看作有 n 个排列成一行的空格，我们需要从左往右依次填入给定的 n 个数，每个数只能使用一次。

最直接的方法就是从左往右每个位置都试一次，在程序中，可以利用**回溯法**来模拟这个过程。



定义一个递归函数 `dfs(nums, ans, id)`表示从左往右填到第 id 个位置，当前排列为 nums。

将数组分成左右两个部份，左边为已填过的树，后面为还没被选择的。在回溯的时候只要动态维护这个数组即可。

具体来说，若我们已经填到第 id 个位置，那么 nums 数组中 [0, id-1] 为已填过的数的集合，而 [id, n-1] 是待填的数的集合，此时则为尝试用 [id, n-1] 的数去填第 id 个位置，假设待填的数下标为 i ，我们只要将下标 i 的数与下标 id 的数进行交换，即能使 nums 数组的 [0, id] 为已填过的数，[id+1, n-1] 是待填的数，回溯时再交换回来即视为撤销操作。

整个递归大致上分成两部份:

- 结束条件: 

  如果 `id == n`，表示已经全部位置皆已排完，找到了一个可行解，将 nums 放入答案数组中，递归结束。

- 进行遍历: 

  因为要进行的是将 nums 数组 [id, n-1] 都尝试放入第 id 个位置，因此 for 循环需从 `i=id` 开始遍历。

  先进行动态维护数组，将后一个数跟该位置进行交换，即 `swap(nums[i], nums[id])`

  接者继续递归下一个数 `dfs(nums, ans, id+1);`

  最后进行**撤销操作** (还原交换)



##### 代码实现

```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        
        vector<vector<int>> ans;

        dfs(nums, ans, 0);

        return ans;
    }

    void dfs(vector<int>& nums, vector<vector<int>>& ans, int id){

        // 结束条件
        if(id==nums.size()){

            ans.push_back(nums);
            return;
        }

        // 排序
        for(int i=id; i<nums.size(); i++){

            // 选
            swap(nums[i], nums[id]);

            // 继续遍历
            dfs(nums, ans, id+1);

            // 回退
            swap(nums[i], nums[id]);
        }
    }
};
```

---

#### 47.全排列II

##### 解题思想

此题跟**40.全排列**的差别在于会出现重复的排列

为了排除重复的方案，需保证"每个元素只在此位固定一次"，**即遇到重复元素不交换，直接跳过**，也就是进行**剪枝**

我们需要建立一个数组 **used** 纪录该数是否已进行过排列，此处以 `set` 形式进行存储，方便排除重复元素



递归过程大致如下:

1. **终止条件:** 当 `id==n-1` 时，代表以全部进行排列，将当前组合 nums 插入 ans 中，并返回
2. 初始化一个 set ，用于排除重复元素
3. **递推工作:**
   1. 进行**剪枝**: 若当前 `nums[i]` 在 set 中有出现，代表重复元素，因此剪枝
   2. 将 `nums[i]` 加入 set
   3. 固定元素: 将 nums[i] 与 nums[id] 进行交换
   4. **下层递归:** 调用 `dfs(id+1)` ，开始固定第 id+1 个元素
   5. **还原交换**



##### 错误思想

我一开始剪枝条件设为 `i>id && nums[i]==nums[id]`，意思是：**如果当前数字 `nums[i]` 与基准位置 `nums[id]` 相同，就跳过**。

**错误原因**: 剪枝条件太强

##### 代码实现

```cpp
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {

        vector<vector<int>> ans;
        sort(nums.begin(), nums.end());

        dfs(nums, ans, 0);

        return ans;
    }

    void dfs(vector<int>& nums, vector<vector<int>>& ans, int id){

        // 结束条件
        if(id==nums.size()){

            ans.push_back(nums);
            return;
        }

        set<int> used;

        // 排序
        for(int i=id; i<nums.size(); i++){
            
            // 剪枝
            if(used.find(nums[i]) != used.end())   // 被使用过
                continue;
            
            used.insert(nums[i]);

            // 选
            swap(nums[i], nums[id]);

            // 继续遍历
            dfs(nums, ans, id+1);

            // 回退
            swap(nums[i], nums[id]);
        }
    }
};
```

