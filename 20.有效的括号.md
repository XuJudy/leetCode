## 有效的括号

> ##### 题目链接
>
> ##### [20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/)
>
> ##### [678. 有效的括号字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parenthesis-string/)



#### 20.有效的括号

##### 解题思想

使用栈进行存储，因为总共有三种类型的括号，使用一个函数将右括号转换为要寻找的左括号，左括号则直接压栈

- 左括号压栈
- 右括号匹配
  - 匹配成功: 出栈
  - 匹配失败: 退出
- 遍历后若栈中仍有元素则也为**无效**括号

###### 注意

1. `if` 要判断的是经过函数转换后的字符 `ch`

2. 左括号需将 `s[i]` 进行入栈

   

##### 代码实现

```cpp
#include<vector>

class Solution {
public:

    char pair(char ch){

        if(ch==')') return '(';
        if(ch=='}') return '{';
        if(ch==']') return '[';

        return 0;   // 左括号
    }
    
    bool isValid(string s) {
        
        int len = s.size();
        stack<char> Stack;
        
        if(len%2==1)	return false;	// 单数则无法完全匹配
        
        for(int i=0; i<len; i++){
            
            char ch = pair(s[i]);
            
            if(ch){	// 右括号: 进行匹配
                
                if(!Stack.empty() && ch==Stack.top())
                    Stack.pop();
                else
                    return false;
            }
            
            else		// 左括号: 直接入栈
                Stack.push(s[i]);
        }
        
        if(!Stack.empty())	return false;
        
        return true;
    }
};
```

---

#### 678. 有效的括号字符串

##### 解题思想

**左括号**及**星号**皆先进行入栈，**右括号**依旧进行匹配

由于星号较为万能，所以先与左括号进行匹配，左括号没了再与星号进行匹配

若左括号与星号皆有剩余，再将两者进行匹配

但星号必须在左括号的右边，即星号的下标应大于左括号，因为此时星号是代替了右括号

为了更好的匹配，此次**入栈时应使用下标进行入栈**

最后，若左括号不为空则匹配失败; 为空则匹配成功。



##### 代码实现

```cpp
class Solution {
public:

    bool checkValidString(string s) {
        
        int len = s.size();
        stack<int> stackLeft, stackStar;
        
        for(int i=0; i<len; i++){
            
            if(s[i]=='(')	// 左括号: 入栈
                stackLeft.push(i);
            
            else if(s[i]=='*')	// 星号: 入栈
                stackStar.push(i);
            
            else{	// 左括号: 匹配
                
                if(!stackLeft.empty())
                    stackLeft.pop();
                
                else if(!stackStar.empty())
                    stackStar.pop();
                
                else
                    return false;
            }
        }
        
        // 检查/匹配左括号与星号
        while(!stackLeft.empty() && !stackStar.empty()){
            
            int leftId = stackLeft.top();
            int starId = stackStar.top();
            
            // 记得出栈
            stackLeft.pop();
            stackStar.pop();
            
            // 若左括号在星号右边 -> 无效
            if(leftId>starId)	return false;
        }
        
        if(!stackLeft.empty())	return false;
        else	return true;
    }
};
```
